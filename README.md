# fucking........
## 动态规划
### 两 字符串/数组 的最大公共子序列长度
子序列不要求元素是连续的，例如 ace 是 abcde 的子序列，以下以数组为例
1. 状态定义：dp[i][j] 为nums1的前i个元素 和 nums2的前j个元素的 最大子序列长度
2. 状态转移方程：
   ```text
   {
      当 nums1[i] == nums2[j] 时：dp[i][j] = dp[i - 1][j - 1] + 1
      当 nums1[i] != nums2[j] 时：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
   }
    ```
3. 答案：dp[n][m]


### 两 字符串/数组 的最大子数组/子串长度
子数组/子串要求元素是连续的，例如 abc 是 abcde 的子数组，以下以数组为例
1. 状态定义：dp[i][j] 为nums1的以元素i结尾 和 nums2以元素j结尾的 最长子数组长度
2. 状态转移方程：
   ```text
   {
      当 nums1[i] == nums2[j] 时：dp[i][j] = dp[i - 1][j - 1] + 1
      当 nums1[i] != nums2[j] 时：dp[i][j] = 0
   }
    ```
3. 答案：max(dp[i][j])
4. 原因：方便下一个状态拼接时，如果nums1[i-1] nums2[j-1]不相同，直接将其视为0，因为不连续了

### dp数组的定义
1. 不要习惯性dp[i][j] = new int[n+1][m+1]，具体要看状态转移方程，如果状态转移方程依赖 i - 1 和 j - 1 才这样定义
2. 如果状态转移方程依赖 i + 1 和 j - 1 这类，更推荐 dp[i][j] = new int[n + 2][m + 2]

### dp 数组的遍历顺序
1. 也要根据状态转移方程来，如果 状态转移依赖 i - 1，就 i++，如果 状态转移依赖 i + 1 就 i--
2. j 同理
